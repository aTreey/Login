#  生成器模式

### 说明
将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现

构建多种不同对象时，逻辑包含在单一方法中，会出现逻辑混乱，比如一大堆嵌套的if else 或者 switch case代码，将构建过程分解为客户（控制器）—指导者— 生成器的关系，使过程更容易管理和复用

### 何为生成器模式
客户端 （Client）：
生成器（Builder）：知道究竟如何在缺少是某些特定信息的情况下建造产品
指导者（Director）：知道Builder应该建造什么，以参数向生成器提供缺少的信息来建造特定产品，并不意味着知道Builder 究竟是什么

 Builder 是一个抽象接口，声明了一个builderPart 方法，该方法由具体的ConcreteBuilder 实现，以构造实际产品，实际的生成器ConcreteBuilder 有个getResult方法，向客户端返回构造完毕的Product
 
 指导者（Director）定义一个Construct 方法，命令Builder 的实例去buildPart， Directer 和 Builder 形成一种聚合关系
 
 客户端Client生成ConcreteBuilder的实例和以Builder实例为初始化参数的Director实例，用于今后的协同工作

### 何时使用

- 需要创建涉及各种部件的复杂对象，创建对象的算法应独立于部件的装配方式，构建组合对象
- 构建过程需要以不同的方式构建对象

#### 生成器抽象工厂对比
 生成器 | 抽象工厂
--------- | -------------
构建复杂对象 | 构建简单或者复杂对象
以多个步骤构建对象｜以单一步骤构建对象
以多种方式构建对象｜以单一方式构建对象
在构建过程的最后一步返回产品 ｜立刻返回产品
专注一个特定产品 | 强调一套产品


### 总结
生成器模式能够帮助构建涉及部件与表现的各种组合的对象。没有这一模式，知道构建对象所需细节的 director 可能最终会变成一个庞大的类，带有无数用于构建同一个类的各种表现的内嵌算法。涉及具有各种特征的角色的游戏，应该使用这一模式
